<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floorball LLM Analysis</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        h1 { color: #1a1a1a; margin-bottom: 10px; }
        .subtitle { color: #666; margin-bottom: 30px; }
        .card { background: white; border-radius: 8px; padding: 24px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .tabs { display: flex; gap: 8px; margin-bottom: 20px; background: white; border-radius: 8px; padding: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .tab-button { flex: 1; padding: 12px 24px; background: transparent; border: none; border-radius: 4px; cursor: pointer; font-size: 15px; font-weight: 500; color: #666; transition: all 0.2s; }
        .tab-button:hover { background: #f5f5f5; color: #333; }
        .tab-button.active { background: #0066cc; color: white; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; color: #333; }
        select, textarea { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
        select:disabled, textarea:disabled, textarea[readonly], input[type="file"]:disabled { background: #f5f5f5; color: #999; cursor: not-allowed; opacity: 0.6; }
        input[type="checkbox"]:disabled { cursor: not-allowed; opacity: 0.6; }
        input[type="number"]:disabled, input[type="text"]:disabled { background: #f5f5f5; color: #999; cursor: not-allowed; opacity: 0.6; }
        textarea { font-family: monospace; }
        .timer-display { font-size: 14px; color: #0066cc; font-weight: bold; margin-top: 8px; font-family: monospace; }
        .time-filter-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
        .time-filter-input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
        button { background: #0066cc; color: white; border: none; padding: 12px 24px; border-radius: 4px; font-size: 16px; cursor: pointer; font-weight: 500; }
        button:hover { background: #0052a3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .status { padding: 12px; border-radius: 4px; margin-bottom: 20px; }
        .status.info { background: #e3f2fd; color: #1976d2; }
        .status.success { background: #e8f5e9; color: #2e7d32; }
        .status.error { background: #ffebee; color: #c62828; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 16px; margin-bottom: 20px; }
        .metric { background: #f9f9f9; padding: 16px; border-radius: 6px; text-align: center; }
        .metric-value { font-size: 24px; font-weight: bold; color: #0066cc; }
        .metric-label { font-size: 12px; color: #666; margin-top: 4px; }
        .events-table { width: 100%; border-collapse: collapse; }
        .events-table th, .events-table td { padding: 12px; text-align: left; border-bottom: 1px solid #eee; }
        .events-table th { background: #f9f9f9; font-weight: 600; }
        .event-badge { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 500; }
        .event-goal { background: #4caf50; color: white; }
        .event-shot { background: #2196f3; color: white; }
        .event-penalty { background: #ff9800; color: white; }
        .event-save { background: #9c27b0; color: white; }
        .event-assist { background: #00bcd4; color: white; }
        .hidden { display: none; }
        .health-status { display: flex; align-items: center; gap: 8px; }
        .health-dot { width: 12px; height: 12px; border-radius: 50%; }
        .health-dot.healthy { background: #4caf50; }
        .health-dot.unhealthy { background: #f44336; }
        .progress-container { margin-top: 16px; padding: 16px; background: #f9f9f9; border-radius: 6px; border: 1px solid #e0e0e0; }
        .progress-bar-wrapper { width: 100%; height: 24px; background: #e0e0e0; border-radius: 12px; overflow: hidden; margin: 12px 0; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #0066cc, #0052a3); transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: bold; }
        .progress-log { background: white; border: 1px solid #ddd; border-radius: 4px; padding: 12px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 13px; margin-top: 12px; }
        .progress-log-entry { padding: 4px 0; color: #333; }
        .progress-log-entry.current { color: #0066cc; font-weight: bold; }
        .progress-step { color: #666; font-size: 14px; }
        .stop-btn { background: #f44336; margin-top: 12px; }
        .stop-btn:hover { background: #d32f2f; }
        .stop-btn:disabled { background: #ccc; cursor: not-allowed; }
        .clips-section { margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee; }
        .generate-clips-btn { background: #4caf50; margin-top: 12px; }
        .generate-clips-btn:hover { background: #45a049; }
        .clips-list { list-style: none; padding: 0; margin-top: 12px; }
        .clips-list li { padding: 8px; background: #f9f9f9; margin-bottom: 8px; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; gap: 12px; }
        .clip-left { display: flex; align-items: center; gap: 8px; flex: 1; }
        .clip-checkbox { width: 18px; height: 18px; cursor: pointer; }
        .clip-download { color: #0066cc; text-decoration: none; font-size: 14px; white-space: nowrap; }
        .clip-download:hover { text-decoration: underline; }
        .clips-controls { margin-top: 16px; display: flex; gap: 10px; flex-wrap: wrap; }
        .select-all-btn { background: #666; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; }
        .select-all-btn:hover { background: #555; }
        .highlight-reel-btn { background: #ff6b35; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; }
        .highlight-reel-btn:hover { background: #e55a2b; }
        .highlight-reel-btn:disabled { background: #ccc; cursor: not-allowed; }
        .highlight-result { margin-top: 12px; padding: 12px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 4px; }
        .highlight-result a { color: #2e7d32; font-weight: bold; text-decoration: none; }
        .highlight-result a:hover { text-decoration: underline; }
        .info-box { background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px; border-radius: 4px; }
        .info-box h3 { color: #1976d2; margin-bottom: 8px; font-size: 16px; }
        .info-box ul { margin-left: 20px; color: #555; font-size: 14px; }
        .info-box li { margin-bottom: 4px; }
        .video-preview { margin-top: 20px; padding: 16px; background: #f9f9f9; border-radius: 6px; }
        .video-preview video { max-width: 100%; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .video-info { margin-top: 10px; color: #666; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèí Floorball LLM Analysis</h1>
        <p class="subtitle">AI-powered game analysis | 
            <a href="/settings" style="color: #0066cc; text-decoration: none; font-weight: 500;">‚öôÔ∏è Settings</a>
        </p>
        
        <div id="healthStatus"></div>
        
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('local')">üíª Local Mode (No Upload)</button>
            <button class="tab-button" onclick="switchTab('upload')">üé• Video Upload</button>
        </div>
        
        <!-- Upload Tab Content -->
        <div id="uploadTab" class="tab-content">
            <div class="card">
                <h2>üé• Video Upload</h2>
            <div class="form-group">
                <label for="videoFile">Upload Game Video</label>
                <input type="file" id="videoFile" accept="video/*">
                <small style="color: #666; display: block; margin-top: 4px;">Supports MP4, MKV, AVI up to 5GB</small>
            </div>
            <div class="form-group">
                <label>‚è±Ô∏è Video Time Range (Optional)</label>
                <div class="time-filter-group">
                    <div>
                        <label style="font-size: 13px; color: #666; font-weight: normal;">From (HH:MM:SS or seconds)</label>
                        <input type="text" id="timeFrom" class="time-filter-input" placeholder="00:00:00 or 0">
                    </div>
                    <div>
                        <label style="font-size: 13px; color: #666; font-weight: normal;">To (HH:MM:SS or seconds)</label>
                        <input type="text" id="timeTo" class="time-filter-input" placeholder="01:30:00 or 5400">
                    </div>
                </div>
                <small style="color: #666; display: block;">Leave empty to analyze entire video. Use to skip unnecessary beginning/end.</small>
            </div>
            <div class="form-group">
                <label>üìã Event Types to Find</label>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px; margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 4px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="upload-event-type-checkbox" value="goal" checked style="margin-right: 6px;">
                        <span>ü•Ö Goals</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="upload-event-type-checkbox" value="shot" style="margin-right: 6px;">
                        <span>üéØ Shots</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="upload-event-type-checkbox" value="save" style="margin-right: 6px;">
                        <span>üß§ Saves</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="upload-event-type-checkbox" value="assist" style="margin-right: 6px;">
                        <span>ü§ù Assists</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="upload-event-type-checkbox" value="penalty" style="margin-right: 6px;">
                        <span>‚ö†Ô∏è Penalties</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="upload-event-type-checkbox" value="turnover" style="margin-right: 6px;">
                        <span>üîÑ Turnovers</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" class="upload-event-type-checkbox" value="timeout" style="margin-right: 6px;">
                        <span>‚è∏Ô∏è Timeouts</span>
                    </label>
                </div>
                <small style="color: #666; display: block; margin-bottom: 8px;">Select event types to search for, or use the text field below for custom instructions</small>
            </div>
            <div class="form-group">
                <label for="instructions">üìù Additional Instructions (Optional)</label>
                <textarea id="instructions" rows="2" placeholder="Add any additional context or specific instructions..."></textarea>
                <small style="color: #666; display: block; margin-top: 4px;">Examples: "Focus on player #7", "Only second half", "Include celebrations"</small>
            </div>
            <button id="analyzeBtn" onclick="analyze()">üîç Analyze Video</button>
            
            <div id="progressContainer" class="progress-container hidden">
                <div class="progress-step" id="progressStep">Step 1/5: Initializing...</div>
                <div class="progress-bar-wrapper">
                    <div class="progress-bar" id="progressBar" style="width: 0%;">0%</div>
                </div>
                <div class="progress-log" id="progressLog"></div>
                <div class="timer-display" id="analysisTimer">‚è±Ô∏è Elapsed: 0s</div>
                <button id="stopBtn" class="stop-btn" onclick="stopAnalysis()">‚õî Stop Analysis</button>
                <button id="resetBtn" class="stop-btn" onclick="resetUploadMode()" style="background:#6c757d;">üîÑ Reset</button>
            </div>
            </div>
        </div>
        
        <!-- Local Mode Tab Content -->
        <div id="localTab" class="tab-content active">
            <div class="card">
                <h2>üíª Local Mode (No Upload)</h2>
                
                <div class="info-box">
                    <h3>‚ú® How It Works</h3>
                    <ul>
                        <li><strong>Your video stays on your computer</strong> - no full upload needed</li>
                        <li><strong>Frames extracted locally</strong> using your browser</li>
                        <li><strong>Only frames sent to AI</strong> (~2-5MB instead of 2GB+)</li>
                        <li><strong>Same analysis quality</strong> as full upload</li>
                        <li><strong>100x faster upload</strong> and more privacy-friendly</li>
                    </ul>
                </div>

                <div class="form-group">
                    <label for="localVideoFile">üìπ Select Video File</label>
                    <input type="file" id="localVideoFile" accept="video/*" onchange="handleLocalVideoSelect(event)">
                    <small style="color: #666; display: block; margin-top: 4px;">Video stays local - only frames are uploaded</small>
                </div>

                <div class="video-preview hidden" id="localVideoPreview">
                    <video id="localVideoElement" controls></video>
                    <p class="video-info" id="localVideoInfo"></p>
                </div>

                <div class="form-group">
                    <label>‚è±Ô∏è Video Time Range (Optional)</label>
                    <div class="time-filter-group">
                        <div>
                            <label style="font-size: 13px; color: #666; font-weight: normal;">From (HH:MM:SS or seconds)</label>
                            <input type="text" id="localTimeFrom" class="time-filter-input" placeholder="00:00:00 or 0">
                        </div>
                        <div>
                            <label style="font-size: 13px; color: #666; font-weight: normal;">To (HH:MM:SS or seconds)</label>
                            <input type="text" id="localTimeTo" class="time-filter-input" placeholder="01:30:00 or 5400">
                        </div>
                    </div>
                    <small style="color: #666; display: block;">Leave empty to analyze entire video. Use to skip unnecessary beginning/end.</small>
                </div>

                <div class="form-group">
                    <label>üìã Event Types to Find</label>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px; margin-bottom: 12px; padding: 12px; background: #f8f9fa; border-radius: 4px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="event-type-checkbox" value="goal" checked style="margin-right: 6px;">
                            <span>ü•Ö Goals</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="event-type-checkbox" value="shot" style="margin-right: 6px;">
                            <span>üéØ Shots</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="event-type-checkbox" value="save" style="margin-right: 6px;">
                            <span>üß§ Saves</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="event-type-checkbox" value="assist" style="margin-right: 6px;">
                            <span>ü§ù Assists</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="event-type-checkbox" value="penalty" style="margin-right: 6px;">
                            <span>‚ö†Ô∏è Penalties</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="event-type-checkbox" value="turnover" style="margin-right: 6px;">
                            <span>üîÑ Turnovers</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" class="event-type-checkbox" value="timeout" style="margin-right: 6px;">
                            <span>‚è∏Ô∏è Timeouts</span>
                        </label>
                    </div>
                    <small style="color: #666; display: block; margin-bottom: 8px;">Select event types to search for, or use the text field below for custom instructions</small>
                </div>

                <div class="form-group">
                    <label for="localInstructions">üìù Additional Instructions (Optional)</label>
                    <textarea id="localInstructions" rows="2" placeholder="Add any additional context or specific instructions..."></textarea>
                    <small style="color: #666; display: block; margin-top: 4px;">Examples: "Focus on player #7", "Only second half", "Include celebrations"</small>
                </div>

                <button id="localAnalyzeBtn" onclick="analyzeLocal()">üîç Analyze Video (Local Mode)</button>

                <div id="localProgressContainer" class="progress-container hidden">
                    <div class="progress-step" id="localProgressStep">Initializing...</div>
                    <div class="progress-bar-wrapper">
                        <div class="progress-bar" id="localProgressBar" style="width: 0%">0%</div>
                    </div>
                    <div class="progress-log" id="localProgressLog"></div>
                    <div class="timer-display" id="localAnalysisTimer">‚è±Ô∏è Elapsed: 0s</div>
                    <button id="localStopBtn" class="stop-btn" onclick="stopLocalAnalysis()" style="margin-top:12px;">‚õî Stop Analysis</button>
                    <button id="localResetBtn" class="stop-btn" onclick="resetLocalMode()" style="margin-top:12px; background:#6c757d;">üîÑ Reset</button>
                </div>
            </div>
        </div>
        

        
        <div id="results" class="hidden">
            <div class="card">
                <h2>Results</h2>
                <div id="metrics" class="metrics"></div>
                <div id="events"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentConfig = {};
        let currentTaskId = null;
        let currentAnalysisResult = null;
        let currentEventSource = null;
        let localVideoFile = null;
        let localVideoElement = null;
        let localAnalysisCancelled = false;
        let selectedEvents = new Set();
        let includeShortDescription = true;
        let analysisStartTime = null;
        let analysisTimerInterval = null;
        let localAnalysisStartTime = null;
        let localAnalysisTimerInterval = null;
        
        // Parse time string (HH:MM:SS or seconds) to seconds
        function parseTimeToSeconds(timeStr) {
            if (!timeStr || timeStr.trim() === '') return null;
            timeStr = timeStr.trim();
            
            // If it's just a number, treat as seconds
            if (/^\d+(\.\d+)?$/.test(timeStr)) {
                return parseFloat(timeStr);
            }
            
            // Parse HH:MM:SS format
            const parts = timeStr.split(':').map(p => parseFloat(p));
            if (parts.length === 3) {
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            } else if (parts.length === 2) {
                return parts[0] * 60 + parts[1];
            } else if (parts.length === 1) {
                return parts[0];
            }
            return null;
        }
        
        // Start timer
        function startAnalysisTimer(isLocal = false) {
            const timerElement = document.getElementById(isLocal ? 'localAnalysisTimer' : 'analysisTimer');
            const startTime = new Date();
            
            if (isLocal) {
                localAnalysisStartTime = startTime;
                if (localAnalysisTimerInterval) clearInterval(localAnalysisTimerInterval);
                localAnalysisTimerInterval = setInterval(() => {
                    const elapsed = Math.floor((new Date() - localAnalysisStartTime) / 1000);
                    timerElement.textContent = `‚è±Ô∏è Elapsed: ${elapsed}s`;
                }, 1000);
            } else {
                analysisStartTime = startTime;
                if (analysisTimerInterval) clearInterval(analysisTimerInterval);
                analysisTimerInterval = setInterval(() => {
                    const elapsed = Math.floor((new Date() - analysisStartTime) / 1000);
                    timerElement.textContent = `‚è±Ô∏è Elapsed: ${elapsed}s`;
                }, 1000);
            }
        }
        
        // Stop timer
        function stopAnalysisTimer(isLocal = false) {
            if (isLocal) {
                if (localAnalysisTimerInterval) {
                    clearInterval(localAnalysisTimerInterval);
                    localAnalysisTimerInterval = null;
                }
            } else {
                if (analysisTimerInterval) {
                    clearInterval(analysisTimerInterval);
                    analysisTimerInterval = null;
                }
            }
        }
        
        function stopLocalAnalysis() {
            localAnalysisCancelled = true;
            document.getElementById('localStopBtn').disabled = true;
            updateLocalProgress(100, '‚õî Analysis stopped by user.');
        }
        
        function resetLocalMode() {
            // Stop analysis if running
            localAnalysisCancelled = true;
            
            // Clear video
            const videoInput = document.getElementById('localVideoFile');
            videoInput.value = '';
            localVideoFile = null;
            localVideoElement = null;
            
            // Hide preview
            document.getElementById('localVideoPreview').classList.add('hidden');
            
            // Reset checkboxes - check only goals
            document.querySelectorAll('.event-type-checkbox').forEach(cb => {
                cb.checked = (cb.value === 'goal');
            });
            
            // Clear instructions
            document.getElementById('localInstructions').value = '';
            
            // Reset progress
            document.getElementById('localProgressContainer').classList.add('hidden');
            document.getElementById('localProgressLog').innerHTML = '';
            document.getElementById('localProgressBar').style.width = '0%';
            document.getElementById('localProgressBar').textContent = '0%';
            
            // Reset buttons
            document.getElementById('localAnalyzeBtn').disabled = false;
            document.getElementById('localAnalyzeBtn').textContent = 'üîç Analyze Video (Local Mode)';
            document.getElementById('localStopBtn').style.display = 'none';
            
            // Hide results
            document.getElementById('results').classList.add('hidden');
            currentAnalysisResult = null;
            selectedEvents.clear();
        }
        
        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.tab-button[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            if (tabName === 'upload') {
                document.getElementById('uploadTab').classList.add('active');
            } else if (tabName === 'local') {
                document.getElementById('localTab').classList.add('active');
            }
            // Hide results when switching tabs
            document.getElementById('results').classList.add('hidden');
        }
        
        // Local video handling
        function handleLocalVideoSelect(event) {
            localVideoFile = event.target.files[0];
            if (localVideoFile) {
                const preview = document.getElementById('localVideoPreview');
                const video = document.getElementById('localVideoElement');
                const info = document.getElementById('localVideoInfo');
                
                video.src = URL.createObjectURL(localVideoFile);
                localVideoElement = video;
                
                video.onloadedmetadata = () => {
                    const duration = Math.round(video.duration);
                    const sizeMB = (localVideoFile.size / 1024 / 1024).toFixed(2);
                    info.textContent = `Duration: ${duration}s | Size: ${sizeMB}MB | Name: ${localVideoFile.name}`;
                    preview.classList.remove('hidden');
                };
            }
        }
        
        // Local analysis function
        async function analyzeLocal() {
            if (!localVideoFile || !localVideoElement) {
                alert('Please select a video file first');
                return;
            }

            const btn = document.getElementById('localAnalyzeBtn');
            const videoInput = document.getElementById('localVideoFile');
            const instructions = document.getElementById('localInstructions');
            const progressContainer = document.getElementById('localProgressContainer');
            const progressBar = document.getElementById('localProgressBar');
            const progressStep = document.getElementById('localProgressStep');
            const progressLog = document.getElementById('localProgressLog');
            const results = document.getElementById('results');

            // Disable all form inputs
            btn.disabled = true;
            videoInput.disabled = true;
            instructions.readOnly = true;
            document.getElementById('localTimeFrom').disabled = true;
            document.getElementById('localTimeTo').disabled = true;
            document.querySelectorAll('.event-type-checkbox').forEach(cb => cb.disabled = true);
            
            btn.textContent = '‚è≥ Processing...';
            progressContainer.classList.remove('hidden');
            results.classList.add('hidden');
            progressLog.innerHTML = '';
            document.getElementById('localStopBtn').disabled = false;
            document.getElementById('localStopBtn').style.display = 'block';
            localAnalysisCancelled = false;
            
            // Start timer
            startAnalysisTimer(true);

            try {
                // Step 0: Upload video file for clip generation (but don't wait for processing)
                updateLocalProgress(5, 'Uploading video for clip generation...');
                const formData = new FormData();
                formData.append('video', localVideoFile);
                
                const uploadResponse = await fetch('/api/video/upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error('Failed to upload video');
                }
                
                const uploadData = await uploadResponse.json();
                currentTaskId = uploadData.task_id;
                console.log(`[${new Date().toLocaleTimeString()}] Video uploaded with task_id: ${currentTaskId}`);
                
                // Step 1: Extract frames locally
                const startTime = new Date();
                updateLocalProgress(10, 'Extracting frames from video...');
                console.log(`[${startTime.toLocaleTimeString()}] === Starting Local Video Analysis ===`);
                console.log(`[${startTime.toLocaleTimeString()}] Video duration: ${localVideoElement.duration.toFixed(2)}s`);
                
                // Get time range filters
                const fromSeconds = parseTimeToSeconds(document.getElementById('localTimeFrom').value);
                const toSeconds = parseTimeToSeconds(document.getElementById('localTimeTo').value);
                const startOffset = fromSeconds || 0;
                const endOffset = toSeconds || localVideoElement.duration;
                
                if (startOffset > 0 || endOffset < localVideoElement.duration) {
                    console.log(`[${new Date().toLocaleTimeString()}] Time filter: ${startOffset.toFixed(1)}s to ${endOffset.toFixed(1)}s`);
                    updateLocalProgress(10, `Extracting frames from ${startOffset.toFixed(1)}s to ${endOffset.toFixed(1)}s...`);
                }
                
                // Get sport config to determine frame interval
                const sport = currentConfig.sport || 'floorball';
                const sportPreset = currentConfig.sport_presets?.[sport];
                const frameInterval = sportPreset?.frame_interval || 2;
                console.log(`[${new Date().toLocaleTimeString()}] Sport: ${sport}, Frame interval: ${frameInterval}s`);
                
                const frames = [];
                const extractedFrames = await extractFramesFromVideo(localVideoElement, frameInterval, startOffset, endOffset);
                for (let i = 0; i < extractedFrames.length; i++) {
                    if (localAnalysisCancelled) {
                        updateLocalProgress(100, '‚õî Analysis stopped by user during frame extraction.');
                        btn.disabled = false;
                        videoInput.disabled = false;
                        instructions.readOnly = false;
                        btn.textContent = 'üîç Analyze Video (Local Mode)';
                        return;
                    }
                    frames.push(extractedFrames[i]);
                }
                const extractTime = ((new Date() - startTime) / 1000).toFixed(1);
                console.log(`[${new Date().toLocaleTimeString()}] Extracted ${frames.length} frames in ${extractTime}s`);
                updateLocalProgress(30, `Extracted ${frames.length} frames locally (${frameInterval}s interval)`);

                // Step 2: Prepare frames for upload
                updateLocalProgress(40, 'Preparing frames for AI analysis...');
                
                // Build instructions from checkboxes and text field
                const selectedEventTypes = Array.from(document.querySelectorAll('.event-type-checkbox:checked'))
                    .map(cb => cb.value);
                const additionalInstructions = instructions.value.trim();
                
                let finalInstructions = '';
                if (selectedEventTypes.length > 0) {
                    finalInstructions = `Find all ${selectedEventTypes.join(', ')}`;
                }
                if (additionalInstructions) {
                    finalInstructions = finalInstructions 
                        ? `${finalInstructions}. ${additionalInstructions}` 
                        : additionalInstructions;
                }
                
                if (!finalInstructions) {
                    alert('Please select at least one event type or provide instructions');
                    btn.disabled = false;
                    videoInput.disabled = false;
                    instructions.readOnly = false;
                    btn.textContent = 'üîç Analyze Video (Local Mode)';
                    return;
                }
                
                console.log(`[${new Date().toLocaleTimeString()}] Instructions: ${finalInstructions}`);
                
                const frameData = frames.map((frame, idx) => ({
                    index: idx,
                    timestamp: frame.timestamp,
                    data: frame.dataUrl
                }));

                // Step 3: Send ALL frames to backend for parallel processing with real-time updates
                const backend = currentConfig.llm_backend || 'simulated';
                console.log(`[${new Date().toLocaleTimeString()}] Backend: ${backend}`);
                console.log(`[${new Date().toLocaleTimeString()}] Sending ${frameData.length} frames for parallel analysis...`);
                updateLocalProgress(20, `Analyzing ${frameData.length} frames with AI backend...`);
                
                const analysisStart = new Date();
                
                // Use EventSource for streaming progress updates
                const eventSource = new EventSource('/api/analyze/frames/stream');
                let allEvents = [];
                let totalChunks = 0;
                
                // Send the request data via POST
                fetch('/api/analyze/frames/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        frames: frameData,
                        instructions: finalInstructions,
                        backend: currentConfig.llm_backend || 'simulated',
                        sport: sport,
                        video_duration: localVideoElement.duration
                    })
                }).then(response => {
                    if (!response.ok) throw new Error('Stream failed to start');
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    function readStream() {
                        reader.read().then(({ done, value }) => {
                            if (done) {
                                console.log('Stream complete');
                                return;
                            }
                            
                            const text = decoder.decode(value);
                            const lines = text.split('\n');
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.substring(6));
                                        
                                        if (localAnalysisCancelled) {
                                            reader.cancel();
                                            updateLocalProgress(100, '‚õî Analysis stopped by user.');
                                            btn.disabled = false;
                                            videoInput.disabled = false;
                                            instructions.readOnly = false;
                                            btn.textContent = 'üîç Analyze Video (Local Mode)';
                                            return;
                                        }
                                        
                                        if (data.type === 'info') {
                                            totalChunks = data.total_chunks;
                                            console.log(`[${new Date().toLocaleTimeString()}] Processing ${data.total_chunks} chunks with ${data.workers} parallel workers`);
                                        } else if (data.type === 'chunk_complete') {
                                            const progress = 20 + Math.round(data.progress * 0.8);
                                            console.log(`[${new Date().toLocaleTimeString()}] Chunk ${data.chunk}/${data.total}: ${data.events} events (${data.completed}/${data.total} complete)`);
                                            updateLocalProgress(progress, `Processing: ${data.completed}/${data.total} chunks complete...`);
                                        } else if (data.type === 'chunk_error') {
                                            console.error(`[${new Date().toLocaleTimeString()}] Chunk ${data.chunk} error: ${data.error}`);
                                        } else if (data.type === 'complete') {
                                            allEvents = data.events;
                                            const totalTime = ((new Date() - analysisStart) / 1000).toFixed(1);
                                            console.log(`[${new Date().toLocaleTimeString()}] === Analysis Complete ===`);
                                            console.log(`[${new Date().toLocaleTimeString()}] Total events: ${allEvents.length}`);
                                            console.log(`[${new Date().toLocaleTimeString()}] Total time: ${totalTime}s`);
                                            console.log(`[${new Date().toLocaleTimeString()}] Parallel workers: ${data.meta.workers}, Chunks: ${data.meta.chunks}`);
                                            
                                            currentAnalysisResult = {
                                                events: allEvents,
                                                meta: { 
                                                    frames_analyzed: frameData.length,
                                                    backend: backend,
                                                    workers: data.meta.workers,
                                                    chunks: data.meta.chunks
                                                },
                                                timestamps: allEvents.map(e => e.timestamp)
                                            };
                                            updateLocalProgress(100, `Complete! Found ${allEvents.length} events in ${totalTime}s`);
                                            displayLocalResults(currentAnalysisResult);
                                            document.getElementById('localStopBtn').style.display = 'none';
                                            stopAnalysisTimer(true);
                                            
                                            btn.disabled = false;
                                            videoInput.disabled = false;
                                            instructions.readOnly = false;
                                            document.getElementById('localTimeFrom').disabled = false;
                                            document.getElementById('localTimeTo').disabled = false;
                                            document.querySelectorAll('.event-type-checkbox').forEach(cb => cb.disabled = false);
                                            btn.textContent = 'üîç Analyze Video (Local Mode)';
                                        } else if (data.type === 'error') {
                                            throw new Error(data.error);
                                        }
                                    } catch (e) {
                                        console.error('Error parsing stream data:', e);
                                    }
                                }
                            }
                            
                            readStream();
                        }).catch(error => {
                            console.error('Stream read error:', error);
                            updateLocalProgress(100, `Error: ${error.message}`);
                            stopAnalysisTimer(true);
                            btn.disabled = false;
                            videoInput.disabled = false;
                            instructions.readOnly = false;
                            document.getElementById('localTimeFrom').disabled = false;
                            document.getElementById('localTimeTo').disabled = false;
                            document.querySelectorAll('.event-type-checkbox').forEach(cb => cb.disabled = false);
                            btn.textContent = 'üîç Analyze Video (Local Mode)';
                        });
                    }
                    
                    readStream();
                }).catch(error => {
                    console.error('Analysis error:', error);
                    updateLocalProgress(100, `Error: ${error.message}`);
                    stopAnalysisTimer(true);
                    btn.disabled = false;
                    videoInput.disabled = false;
                    instructions.readOnly = false;
                    document.getElementById('localTimeFrom').disabled = false;
                    document.getElementById('localTimeTo').disabled = false;
                    document.querySelectorAll('.event-type-checkbox').forEach(cb => cb.disabled = false);
                    btn.textContent = 'üîç Analyze Video (Local Mode)';
                });
                
                return; // Exit here since streaming handles everything

            } catch (error) {
                console.error(error);
                alert('Error: ' + error.message);
                updateLocalProgress(0, 'Error: ' + error.message);
                stopAnalysisTimer(true);
            } finally {
                btn.disabled = false;
                videoInput.disabled = false;
                instructions.readOnly = false;
                document.getElementById('localTimeFrom').disabled = false;
                document.getElementById('localTimeTo').disabled = false;
                document.querySelectorAll('.event-type-checkbox').forEach(cb => cb.disabled = false);
                btn.textContent = 'üîç Analyze Video (Local Mode)';
            }
        }

        async function extractFramesFromVideo(video, intervalSeconds, startTime = 0, endTime = null) {
            const frames = [];
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 640;
            canvas.height = 360;

            const duration = endTime || video.duration;
            const effectiveStart = startTime || 0;
            const numFrames = Math.floor((duration - effectiveStart) / intervalSeconds);

            for (let i = 0; i < numFrames; i++) {
                const timestamp = effectiveStart + (i * intervalSeconds);
                if (timestamp >= duration) break;
                
                video.currentTime = timestamp;
                
                await new Promise(resolve => {
                    video.onseeked = () => {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        frames.push({ timestamp, dataUrl });
                        updateLocalProgress(10 + (i / numFrames) * 20, `Extracting frame ${i + 1}/${numFrames}...`);
                        resolve();
                    };
                });
            }

            return frames;
        }

        function updateLocalProgress(percent, message) {
            const progressBar = document.getElementById('localProgressBar');
            const progressStep = document.getElementById('localProgressStep');
            const progressLog = document.getElementById('localProgressLog');
            
            progressBar.style.width = percent + '%';
            progressBar.textContent = Math.round(percent) + '%';
            progressStep.textContent = message;
            
            const entry = document.createElement('div');
            entry.className = 'progress-log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            progressLog.appendChild(entry);
            progressLog.scrollTop = progressLog.scrollHeight;
        }

        function displayLocalResults(data) {
            const results = document.getElementById('results');
            const meta = data.meta || {};
            
            // Show metrics
            document.getElementById('metrics').innerHTML = `
                <div class="metric">
                    <div class="metric-value">${data.events.length}</div>
                    <div class="metric-label">Events Found</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${meta.frames_analyzed || 0}</div>
                    <div class="metric-label">Frames Analyzed</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${meta.backend || 'N/A'}</div>
                    <div class="metric-label">AI Backend</div>
                </div>
            `;
            
            // Show timestamps for local clipping
            if (data.timestamps && data.timestamps.length > 0) {
                const timestampsList = data.timestamps.map(t => {
                    const hours = Math.floor(t / 3600);
                    const mins = Math.floor((t % 3600) / 60);
                    const secs = Math.floor(t % 60);
                    return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                }).join(', ');
                
                document.getElementById('metrics').innerHTML += `
                    <div class="metric" style="grid-column: 1 / -1;">
                        <div style="font-size: 14px; font-weight: bold; margin-bottom: 8px;">‚è±Ô∏è Timestamps for Local Clipping:</div>
                        <div style="font-family: monospace; font-size: 12px; background: #fff; padding: 8px; border-radius: 4px; border: 1px solid #ddd; margin-bottom: 12px;">${timestampsList}</div>
                        <button onclick="downloadTimestamps()" style="background: #666; padding: 8px 16px; border-radius: 4px; border: none; color: white; cursor: pointer; font-size: 13px;">
                            ‚¨áÔ∏è Download Timestamps (JSON)
                        </button>
                        <button onclick="showClipInstructions()" style="background: #0066cc; padding: 8px 16px; border-radius: 4px; border: none; color: white; cursor: pointer; font-size: 13px; margin-left: 8px;">
                            üìñ How to Generate Clips Locally
                        </button>
                    </div>
                `;
            }
            
            // Show events table
            if (data.events.length > 0) {
                // Initialize all events as selected
                selectedEvents = new Set(data.events.map((e, idx) => idx));
                
                const eventsHtml = `
                    <h3>Detected Events</h3>
                    <div style="margin-bottom: 16px; padding: 12px; background: #f8f9fa; border-radius: 4px;">
                        <button onclick="selectAllEvents(true)" style="background: #28a745; padding: 6px 12px; border-radius: 4px; border: none; color: white; cursor: pointer; font-size: 12px; margin-right: 8px;">‚úì Select All</button>
                        <button onclick="selectAllEvents(false)" style="background: #dc3545; padding: 6px 12px; border-radius: 4px; border: none; color: white; cursor: pointer; font-size: 12px; margin-right: 8px;">‚úó Deselect All</button>
                        <button onclick="clearAllFilters()" class="clear-filters-btn">üîÑ Clear Filters</button>
                        <br><br>
                        <div style="background: white; padding: 12px; border-radius: 4px; border: 1px solid #ddd;">
                            <strong style="font-size: 13px; color: #333;">Download Options:</strong>
                            <button onclick="downloadSelectedTimestamps()" style="background: #007bff; padding: 6px 12px; border-radius: 4px; border: none; color: white; cursor: pointer; font-size: 12px; margin-left: 8px; margin-right: 8px;">üìÑ Timestamps (TXT)</button>
                            <button onclick="generateAndDownloadSelectedClips()" id="generateDownloadBtn" style="background: #17a2b8; padding: 6px 12px; border-radius: 4px; border: none; color: white; cursor: pointer; font-size: 12px; margin-right: 8px;">üé¨ Individual Clips</button>
                            <button onclick="generateAndDownloadHighlightReel()" id="highlightReelBtn" style="background: #6f42c1; padding: 6px 12px; border-radius: 4px; border: none; color: white; cursor: pointer; font-size: 12px;">‚ú® Combined Highlight Reel</button>
                        </div>
                        <label style="margin-left: 16px; font-size: 13px;">
                            <input type="checkbox" id="includeDescriptionCheckbox" checked onchange="includeShortDescription = this.checked" style="margin-right: 4px;">
                            Include short description
                        </label>
                        <span style="margin-left: 16px; font-size: 13px; color: #666;">Selected: <strong id="selectedCount">${data.events.length}</strong>/${data.events.length}</span>
                        <span id="localFilteredCount" style="margin-left: 12px; font-size: 13px; color: #666;"></span>
                    </div>
                    <table class="events-table" id="eventsTable">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" id="selectAllCheckbox" checked title="Select All / None" onchange="toggleEventSelectAll()">
                                </th>
                                <th>Type</th>
                                <th>Time</th>
                                <th>Description</th>
                                <th>Confidence</th>
                            </tr>
                            <tr class="filter-row">
                                <th></th>
                                <th><input type="text" class="filter-input" id="filterType" placeholder="Filter type..." oninput="filterEvents()"></th>
                                <th><input type="text" class="filter-input" id="filterTime" placeholder="Filter time..." oninput="filterEvents()"></th>
                                <th><input type="text" class="filter-input" id="filterDescription" placeholder="Filter description..." oninput="filterEvents()"></th>
                                <th><input type="text" class="filter-input" id="filterConfidence" placeholder="Filter..." oninput="filterEvents()"></th>
                            </tr>
                        </thead>
                        <tbody id="eventsTableBody">
                            ${data.events.map((e, idx) => `
                                <tr class="event-row" data-event-index="${idx}">
                                    <td><input type="checkbox" class="event-checkbox" data-index="${idx}" checked onchange="toggleEventSelection(${idx})" style="cursor: pointer;"></td>
                                    <td><span class="event-badge event-${e.type}">${e.type.toUpperCase()}</span></td>
                                    <td>${Math.floor(e.timestamp / 60)}:${String(Math.floor(e.timestamp % 60)).padStart(2, '0')}</td>
                                    <td>${e.description || 'N/A'}</td>
                                    <td>${e.confidence ? (e.confidence * 100).toFixed(0) + '%' : 'N/A'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                document.getElementById('events').innerHTML = eventsHtml;
            } else {
                document.getElementById('events').innerHTML = '<p>No events detected.</p>';
            }
            
            results.classList.remove('hidden');
        }

        function toggleEventSelection(index) {
            if (selectedEvents.has(index)) {
                selectedEvents.delete(index);
            } else {
                selectedEvents.add(index);
            }
            updateSelectedCount();
        }

        function toggleEventSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const isChecked = selectAllCheckbox.checked;
            
            // Get all visible (filtered) event rows
            const rows = document.querySelectorAll('#eventsTableBody .event-row');
            const visibleIndices = [];
            
            rows.forEach((row, idx) => {
                if (row.style.display !== 'none') {
                    visibleIndices.push(idx);
                }
            });
            
            // Toggle selection only for visible events
            const checkboxes = document.querySelectorAll('.event-checkbox');
            visibleIndices.forEach(idx => {
                if (checkboxes[idx]) {
                    checkboxes[idx].checked = isChecked;
                    if (isChecked) {
                        selectedEvents.add(idx);
                    } else {
                        selectedEvents.delete(idx);
                    }
                }
            });
            
            updateSelectedCount();
        }
        
        function selectAllEvents(select) {
            const checkboxes = document.querySelectorAll('.event-checkbox');
            checkboxes.forEach((cb, idx) => {
                cb.checked = select;
                if (select) {
                    selectedEvents.add(idx);
                } else {
                    selectedEvents.delete(idx);
                }
            });
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const countEl = document.getElementById('selectedCount');
            if (countEl) {
                countEl.textContent = selectedEvents.size;
            }
        }
        
        function getVisibleEventIndices() {
            const rows = document.querySelectorAll('#eventsTableBody .event-row');
            const visibleIndices = [];
            rows.forEach((row, idx) => {
                if (row.style.display !== 'none') {
                    visibleIndices.push(idx);
                }
            });
            return visibleIndices;
        }

        function filterEvents() {
            const typeFilter = document.getElementById('filterType')?.value.toLowerCase() || '';
            const timeFilter = document.getElementById('filterTime')?.value.toLowerCase() || '';
            const descFilter = document.getElementById('filterDescription')?.value.toLowerCase() || '';
            const confFilter = document.getElementById('filterConfidence')?.value.trim() || '';
            
            const rows = document.querySelectorAll('#eventsTableBody .event-row');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const type = row.querySelector('.event-badge')?.textContent.toLowerCase() || '';
                const time = row.querySelectorAll('td')[2]?.textContent.toLowerCase() || '';
                const desc = row.querySelectorAll('td')[3]?.textContent.toLowerCase() || '';
                const confText = row.querySelectorAll('td')[4]?.textContent || '';
                
                const typeMatch = type.includes(typeFilter);
                const timeMatch = time.includes(timeFilter);
                const descMatch = desc.includes(descFilter.toLowerCase());
                
                // Parse confidence value (e.g., "85%" -> 85)
                const confValue = parseFloat(confText.replace('%', ''));
                let confMatch = true;
                
                if (confFilter) {
                    // Check for comparison operators
                    if (confFilter.startsWith('>=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue >= threshold;
                    } else if (confFilter.startsWith('<=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue <= threshold;
                    } else if (confFilter.startsWith('>')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue > threshold;
                    } else if (confFilter.startsWith('<')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue < threshold;
                    } else {
                        // Default: exact match or contains
                        confMatch = confText.toLowerCase().includes(confFilter.toLowerCase());
                    }
                }
                
                if (typeMatch && timeMatch && descMatch && confMatch) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update filter status indicators
            updateFilterStatus('filterType', typeFilter);
            updateFilterStatus('filterTime', timeFilter);
            updateFilterStatus('filterDescription', descFilter);
            updateFilterStatus('filterConfidence', confFilter);
            
            // Update filtered count
            const totalCount = rows.length;
            const countEl = document.getElementById('localFilteredCount');
            if (countEl) {
                if (visibleCount < totalCount) {
                    countEl.textContent = `Showing ${visibleCount} of ${totalCount} events`;
                    countEl.style.color = '#007bff';
                    countEl.style.fontWeight = 'bold';
                } else {
                    countEl.textContent = '';
                }
            }
        }

        function filterUploadEvents() {
            const typeFilter = document.getElementById('uploadFilterType')?.value.toLowerCase() || '';
            const timeFilter = document.getElementById('uploadFilterTime')?.value.toLowerCase() || '';
            const descFilter = document.getElementById('uploadFilterDescription')?.value.toLowerCase() || '';
            const confFilter = document.getElementById('uploadFilterConfidence')?.value.trim() || '';
            
            const rows = document.querySelectorAll('#uploadEventsTableBody tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length === 0) return;
                
                const type = cells[0]?.textContent.toLowerCase() || '';
                const time = cells[1]?.textContent.toLowerCase() || '';
                const desc = cells[2]?.textContent.toLowerCase() || '';
                const confText = cells[3]?.textContent || '';
                
                const typeMatch = type.includes(typeFilter);
                const timeMatch = time.includes(timeFilter);
                const descMatch = desc.includes(descFilter.toLowerCase());
                
                // Parse confidence value (e.g., "85%" -> 85)
                const confValue = parseFloat(confText.replace('%', ''));
                let confMatch = true;
                
                if (confFilter) {
                    // Check for comparison operators
                    if (confFilter.startsWith('>=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue >= threshold;
                    } else if (confFilter.startsWith('<=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue <= threshold;
                    } else if (confFilter.startsWith('>')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue > threshold;
                    } else if (confFilter.startsWith('<')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue < threshold;
                    } else {
                        // Default: exact match or contains
                        confMatch = confText.toLowerCase().includes(confFilter.toLowerCase());
                    }
                }
                
                if (typeMatch && timeMatch && descMatch && confMatch) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update filter status indicators
            updateFilterStatus('uploadFilterType', typeFilter);
            updateFilterStatus('uploadFilterTime', timeFilter);
            updateFilterStatus('uploadFilterDescription', descFilter);
            updateFilterStatus('uploadFilterConfidence', confFilter);
            
            // Update filtered count
            const totalCount = rows.length;
            const countEl = document.getElementById('filteredCount');
            if (countEl) {
                if (visibleCount < totalCount) {
                    countEl.textContent = `Showing ${visibleCount} of ${totalCount} events`;
                    countEl.style.color = '#007bff';
                    countEl.style.fontWeight = 'bold';
                } else {
                    countEl.textContent = '';
                }
            }
        }

        function updateFilterStatus(inputId, filterValue) {
            const input = document.getElementById(inputId);
            if (input) {
                if (filterValue) {
                    input.classList.add('filter-active');
                } else {
                    input.classList.remove('filter-active');
                }
            }
        }

        function clearAllFilters() {
            // Clear local mode filters
            ['filterType', 'filterTime', 'filterDescription', 'filterConfidence'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.value = '';
                    input.classList.remove('filter-active');
                }
            });
            
            // Clear upload mode filters
            ['uploadFilterType', 'uploadFilterTime', 'uploadFilterDescription', 'uploadFilterConfidence'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.value = '';
                    input.classList.remove('filter-active');
                }
            });
            
            // Re-run filters to show all rows
            filterEvents();
            filterUploadEvents();
            
            console.log('[Filter] All filters cleared');
        }

        function filterEvents() {
            const typeFilter = document.getElementById('filterType')?.value.toLowerCase() || '';
            const timeFilter = document.getElementById('filterTime')?.value.toLowerCase() || '';
            const descFilter = document.getElementById('filterDescription')?.value.toLowerCase() || '';
            const confFilter = document.getElementById('filterConfidence')?.value.trim() || '';
            
            const rows = document.querySelectorAll('#eventsTableBody .event-row');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const type = row.querySelector('.event-badge')?.textContent.toLowerCase() || '';
                const time = row.querySelectorAll('td')[2]?.textContent.toLowerCase() || '';
                const desc = row.querySelectorAll('td')[3]?.textContent.toLowerCase() || '';
                const confText = row.querySelectorAll('td')[4]?.textContent || '';
                
                const typeMatch = type.includes(typeFilter);
                const timeMatch = time.includes(timeFilter);
                const descMatch = desc.includes(descFilter.toLowerCase());
                
                // Parse confidence value (e.g., "85%" -> 85)
                const confValue = parseFloat(confText.replace('%', ''));
                let confMatch = true;
                
                if (confFilter) {
                    // Check for comparison operators
                    if (confFilter.startsWith('>=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue >= threshold;
                    } else if (confFilter.startsWith('<=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue <= threshold;
                    } else if (confFilter.startsWith('>')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue > threshold;
                    } else if (confFilter.startsWith('<')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue < threshold;
                    } else {
                        // Default: exact match or contains
                        confMatch = confText.toLowerCase().includes(confFilter.toLowerCase());
                    }
                }
                
                if (typeMatch && timeMatch && descMatch && confMatch) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update filter status indicators
            updateFilterStatus('filterType', typeFilter);
            updateFilterStatus('filterTime', timeFilter);
            updateFilterStatus('filterDescription', descFilter);
            updateFilterStatus('filterConfidence', confFilter);
            
            // Update filtered count
            const totalCount = rows.length;
            const countEl = document.getElementById('localFilteredCount');
            if (countEl) {
                if (visibleCount < totalCount) {
                    countEl.textContent = `Showing ${visibleCount} of ${totalCount} events`;
                    countEl.style.color = '#007bff';
                    countEl.style.fontWeight = 'bold';
                } else {
                    countEl.textContent = '';
                }
            }
        }

        function filterUploadEvents() {
            const typeFilter = document.getElementById('uploadFilterType')?.value.toLowerCase() || '';
            const timeFilter = document.getElementById('uploadFilterTime')?.value.toLowerCase() || '';
            const descFilter = document.getElementById('uploadFilterDescription')?.value.toLowerCase() || '';
            const confFilter = document.getElementById('uploadFilterConfidence')?.value.trim() || '';
            
            const rows = document.querySelectorAll('#uploadEventsTableBody tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length === 0) return;
                
                const type = cells[0]?.textContent.toLowerCase() || '';
                const time = cells[1]?.textContent.toLowerCase() || '';
                const desc = cells[2]?.textContent.toLowerCase() || '';
                const confText = cells[3]?.textContent || '';
                
                const typeMatch = type.includes(typeFilter);
                const timeMatch = time.includes(timeFilter);
                const descMatch = desc.includes(descFilter.toLowerCase());
                
                // Parse confidence value (e.g., "85%" -> 85)
                const confValue = parseFloat(confText.replace('%', ''));
                let confMatch = true;
                
                if (confFilter) {
                    // Check for comparison operators
                    if (confFilter.startsWith('>=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue >= threshold;
                    } else if (confFilter.startsWith('<=')) {
                        const threshold = parseFloat(confFilter.substring(2).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue <= threshold;
                    } else if (confFilter.startsWith('>')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue > threshold;
                    } else if (confFilter.startsWith('<')) {
                        const threshold = parseFloat(confFilter.substring(1).replace('%', ''));
                        confMatch = !isNaN(confValue) && !isNaN(threshold) && confValue < threshold;
                    } else {
                        // Default: exact match or contains
                        confMatch = confText.toLowerCase().includes(confFilter.toLowerCase());
                    }
                }
                
                if (typeMatch && timeMatch && descMatch && confMatch) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update filter status indicators
            updateFilterStatus('uploadFilterType', typeFilter);
            updateFilterStatus('uploadFilterTime', timeFilter);
            updateFilterStatus('uploadFilterDescription', descFilter);
            updateFilterStatus('uploadFilterConfidence', confFilter);
            
            // Update filtered count
            const totalCount = rows.length;
            const countEl = document.getElementById('filteredCount');
            if (countEl) {
                if (visibleCount < totalCount) {
                    countEl.textContent = `Showing ${visibleCount} of ${totalCount} events`;
                    countEl.style.color = '#007bff';
                    countEl.style.fontWeight = 'bold';
                } else {
                    countEl.textContent = '';
                }
            }
        }

        function updateFilterStatus(inputId, filterValue) {
            const input = document.getElementById(inputId);
            if (input) {
                if (filterValue) {
                    input.classList.add('filter-active');
                } else {
                    input.classList.remove('filter-active');
                }
            }
        }

        function clearAllFilters() {
            // Clear local mode filters
            ['filterType', 'filterTime', 'filterDescription', 'filterConfidence'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.value = '';
                    input.classList.remove('filter-active');
                }
            });
            
            // Clear upload mode filters
            ['uploadFilterType', 'uploadFilterTime', 'uploadFilterDescription', 'uploadFilterConfidence'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.value = '';
                    input.classList.remove('filter-active');
                }
            });
            
            // Re-run filters to show all rows
            filterEvents();
            filterUploadEvents();
            
            console.log('[Filter] All filters cleared');
        }

        function downloadSelectedTimestamps() {
            if (!currentAnalysisResult) return;
            
            // Get visible (filtered) event indices
            const visibleIndices = getVisibleEventIndices();
            
            const selectedEventsList = currentAnalysisResult.events
                .filter((e, idx) => selectedEvents.has(idx) && visibleIndices.includes(idx))
                .map(e => {
                    const hours = Math.floor(e.timestamp / 3600);
                    const mins = Math.floor((e.timestamp % 3600) / 60);
                    const secs = Math.floor(e.timestamp % 60);
                    const timeStr = `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                    
                    if (includeShortDescription) {
                        // Create short description (first 50 chars)
                        const shortDesc = e.description ? e.description.substring(0, 50).replace(/[\n\r]/g, ' ').trim() : e.type;
                        return `${timeStr} "${shortDesc}"`;
                    } else {
                        return timeStr;
                    }
                });
            
            const content = selectedEventsList.join('\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `timestamps_${new Date().toISOString().slice(0,10)}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        async function generateAndDownloadSelectedClips() {
            if (!currentTaskId || !currentAnalysisResult) {
                alert('No analysis data available');
                return;
            }
            
            if (selectedEvents.size === 0) {
                alert('Please select at least one event to generate clips');
                return;
            }
            
            const btn = document.getElementById('generateDownloadBtn');
            const originalText = btn.textContent;
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating clips...';
            
            try {
                // Get visible (filtered) event indices
                const visibleIndices = getVisibleEventIndices();
                
                // Get only selected AND visible events
                const selectedEventsList = currentAnalysisResult.events
                    .filter((e, idx) => selectedEvents.has(idx) && visibleIndices.includes(idx));
                
                const response = await fetch('/api/clips/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        task_id: currentTaskId,
                        events: selectedEventsList
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to generate clips');
                }
                
                const clips = data.clips || [];
                
                if (clips.length > 0) {
                    btn.textContent = `‚è≥ Downloading ${clips.length} clips...`;
                    
                    // Download each clip with a small delay
                    for (let i = 0; i < clips.length; i++) {
                        await new Promise(resolve => setTimeout(resolve, i * 500)); // 500ms delay between downloads
                        const a = document.createElement('a');
                        a.href = `/api/clips/download/${clips[i].filename}`;
                        a.download = clips[i].filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }
                    
                    btn.textContent = `‚úÖ ${clips.length} Clips Downloaded`;
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.disabled = false;
                    }, 3000);
                } else {
                    alert('No clips were generated');
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
                
            } catch (error) {
                alert('Error generating clips: ' + error.message);
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }
        
        async function generateAndDownloadHighlightReel() {
            if (!currentTaskId || !currentAnalysisResult) {
                alert('No analysis data available');
                return;
            }
            
            if (selectedEvents.size === 0) {
                alert('Please select at least one event to create a highlight reel');
                return;
            }
            
            const btn = document.getElementById('highlightReelBtn');
            const originalText = btn.textContent;
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating clips...';
            
            try {
                // Get visible (filtered) event indices
                const visibleIndices = getVisibleEventIndices();
                
                // Get only selected AND visible events
                const selectedEventsList = currentAnalysisResult.events
                    .filter((e, idx) => selectedEvents.has(idx) && visibleIndices.includes(idx));
                
                // Step 1: Generate clips
                const generateResponse = await fetch('/api/clips/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        task_id: currentTaskId,
                        events: selectedEventsList
                    })
                });
                
                const generateData = await generateResponse.json();
                
                if (!generateResponse.ok) {
                    throw new Error(generateData.error || 'Failed to generate clips');
                }
                
                const clips = generateData.clips || [];
                
                if (clips.length === 0) {
                    alert('No clips were generated');
                    btn.textContent = originalText;
                    btn.disabled = false;
                    return;
                }
                
                btn.textContent = '‚è≥ Creating highlight reel...';
                
                // Step 2: Concatenate clips
                const clipFilenames = clips.map(c => c.filename);
                
                const concatResponse = await fetch('/api/clips/concatenate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ clips: clipFilenames })
                });
                
                const concatData = await concatResponse.json();
                
                if (!concatResponse.ok) {
                    throw new Error(concatData.error || 'Failed to create highlight reel');
                }
                
                btn.textContent = '‚è≥ Downloading...';
                
                // Step 3: Auto-download the highlight reel
                const a = document.createElement('a');
                a.href = `/api/clips/download/${concatData.filename}`;
                a.download = concatData.filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                btn.textContent = `‚úÖ Highlight Reel Downloaded (${clips.length} clips)`;
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 3000);
                
            } catch (error) {
                alert('Error creating highlight reel: ' + error.message);
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        function downloadTimestamps() {
            if (!currentAnalysisResult) return;
            
            const dataStr = JSON.stringify(currentAnalysisResult, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'analysis_results.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showClipInstructions() {
            const instructions = `To generate clips locally using ffmpeg:

1. Download and install ffmpeg: https://ffmpeg.org/download.html

2. Use this command for each event:
   ffmpeg -i video.mp4 -ss START_TIME -t DURATION -c copy clip.mp4

Example for event at 2:15 (135 seconds):
   ffmpeg -i myvideo.mp4 -ss 130 -t 10 -c copy goal_2min15s.mp4

3. The downloaded JSON file contains all event timestamps!

4. For batch processing, create a script that loops through the timestamps.`;

            alert(instructions);
        }
        
        
        // Load current configuration
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                currentConfig = await response.json();
                console.log('Config loaded:', {
                    sport: currentConfig.sport,
                    frame_interval: currentConfig.sport_presets?.[currentConfig.sport]?.frame_interval,
                    max_frames: currentConfig.sport_presets?.[currentConfig.sport]?.max_frames
                });
            } catch (error) {
                console.error('Failed to load config:', error);
            }
        }
        
        // Check health on load
        Promise.all([
            fetch('/api/health').then(r => r.json()),
            loadConfig()
        ]).then(([healthData]) => {
                const status = document.getElementById('healthStatus');
                const healthy = healthData.backend_healthy;
                status.innerHTML = `
                    <div class="status ${healthy ? 'success' : 'error'}">
                        <div class="health-status">
                            <span class="health-dot ${healthy ? 'healthy' : 'unhealthy'}"></span>
                            <span>Backend: ${healthData.backend} - ${healthy ? 'Healthy' : 'Unavailable'}</span>
                        </div>
                    </div>
                `;
            })
            .catch(e => {
                document.getElementById('healthStatus').innerHTML = `
                    <div class="status error">System error: ${e.message}</div>
                `;
            });
        

        
        async function analyze() {
            console.log('=== ANALYSIS STARTED ===');
            const btn = document.getElementById('analyzeBtn');
            const videoFile = document.getElementById('videoFile').files[0];
            const videoFileInput = document.getElementById('videoFile');
            const instructions = document.getElementById('instructions');
            const results = document.getElementById('results');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressStep = document.getElementById('progressStep');
            const progressLog = document.getElementById('progressLog');
            
            // Build instructions from checkboxes and text field
            const selectedEventTypes = Array.from(document.querySelectorAll('.upload-event-type-checkbox:checked'))
                .map(cb => cb.value);
            const additionalInstructions = instructions.value.trim();
            
            let finalInstructions = '';
            if (selectedEventTypes.length > 0) {
                finalInstructions = `Find all ${selectedEventTypes.join(', ')}`;
            }
            if (additionalInstructions) {
                finalInstructions = finalInstructions 
                    ? `${finalInstructions}. ${additionalInstructions}` 
                    : additionalInstructions;
            }
            
            if (!finalInstructions) {
                alert('Please select at least one event type or provide instructions');
                return;
            }
            
            console.log('Video file:', videoFile ? videoFile.name : 'NONE');
            console.log('Instructions:', finalInstructions);
            console.log('Current config:', currentConfig);
            
            if (!videoFile) {
                console.error('ERROR: No video file selected');
                alert('Please upload a video file');
                return;
            }
            
            // Disable all inputs
            btn.disabled = true;
            videoFileInput.disabled = true;
            instructions.readOnly = true;
            document.getElementById('timeFrom').disabled = true;
            document.getElementById('timeTo').disabled = true;
            document.querySelectorAll('.upload-event-type-checkbox').forEach(cb => cb.disabled = true);
            
            btn.textContent = '‚è≥ Analyzing video...';
            results.classList.add('hidden');
            progressContainer.classList.remove('hidden');
            progressLog.innerHTML = '';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            document.getElementById('stopBtn').style.display = 'block';
            document.getElementById('stopBtn').disabled = false;
            
            // Start timer
            startAnalysisTimer(false);
            
            try {
                console.log('Step 1: Preparing to upload video...');
                // Step 1: Start processing and get task ID
                const formData = new FormData();
                formData.append('video', videoFile);
                formData.append('instructions', finalInstructions);
                formData.append('backend', currentConfig.llm_backend || 'simulated');
                formData.append('sport', currentConfig.sport || 'floorball');
                
                // Add time range filters if specified
                const fromSeconds = parseTimeToSeconds(document.getElementById('timeFrom').value);
                const toSeconds = parseTimeToSeconds(document.getElementById('timeTo').value);
                if (fromSeconds !== null) formData.append('time_from', fromSeconds);
                if (toSeconds !== null) formData.append('time_to', toSeconds);
                
                console.log('Sending POST to /api/analyze/start with:', {
                    videoName: videoFile.name,
                    videoSize: videoFile.size,
                    backend: currentConfig.llm_backend || 'simulated',
                    sport: currentConfig.sport || 'floorball'
                });
                
                const startResponse = await fetch('/api/analyze/start', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Response status:', startResponse.status);
                const startData = await startResponse.json();
                console.log('Response data:', startData);
                
                if (!startResponse.ok) {
                    console.error('ERROR: Failed to start analysis:', startData.error);
                    throw new Error(startData.error || 'Failed to start analysis');
                }
                
                const taskId = startData.task_id;
                currentTaskId = taskId;
                console.log('Task ID assigned:', taskId);
                
                // Step 2: Connect to progress stream
                console.log('Step 2: Connecting to SSE stream...');
                const eventSource = new EventSource(`/api/analyze/progress/${taskId}`);
                currentEventSource = eventSource;
                console.log('SSE connection established');
                
                eventSource.onmessage = function(event) {
                    const update = JSON.parse(event.data);
                    console.log('SSE Update received:', update);
                    
                    if (update.keepalive) {
                        return; // Ignore keepalive messages
                    }
                    
                    if (update.error) {
                        console.error('=== ANALYSIS FAILED ===');
                        console.error('Error:', update.error);
                        eventSource.close();
                        currentEventSource = null;
                        progressContainer.classList.add('hidden');
                        stopAnalysisTimer(false);
                        btn.disabled = false;
                        videoFileInput.disabled = false;
                        instructions.readOnly = false;
                        document.getElementById('timeFrom').disabled = false;
                        document.getElementById('timeTo').disabled = false;
                        document.querySelectorAll('.upload-event-type-checkbox').forEach(cb => cb.disabled = false);
                        btn.textContent = 'üîç Analyze Video';
                        
                        // Show error with details
                        const errorMsg = update.error.includes('GEMINI_API_KEY') 
                            ? update.error + '\n\nGet your free API key at: https://aistudio.google.com/app/apikey'
                            : update.error;
                        alert('Analysis failed:\n\n' + errorMsg);
                        return;
                    }
                    
                    if (update.complete && update.result) {
                        console.log('=== ANALYSIS COMPLETE ===');
                        console.log('Result:', update.result);
                        console.log('Events found:', update.result.events?.length || 0);
                        if (update.result.cancelled) {
                            console.log('Analysis was stopped by user - showing partial results');
                        }
                        if (update.result.events?.length === 0 && !update.result.cancelled) {
                            console.warn('WARNING: No events were detected in the video');
                            console.warn('Try adjusting your instructions or check if the video contains the events you\'re looking for');
                        }
                        eventSource.close();
                        currentEventSource = null;
                        progressContainer.classList.add('hidden');
                        currentAnalysisResult = update.result;
                        displayResults(update.result);
                        stopAnalysisTimer(false);
                        btn.disabled = false;
                        videoFileInput.disabled = false;
                        instructions.readOnly = false;
                        document.getElementById('timeFrom').disabled = false;
                        document.getElementById('timeTo').disabled = false;
                        document.querySelectorAll('.upload-event-type-checkbox').forEach(cb => cb.disabled = false);
                        btn.textContent = 'üîç Analyze Video';
                        
                        // Hide stop button when analysis is complete
                        document.getElementById('stopBtn').style.display = 'none';
                        
                        // Reset stop button for next analysis
                        const stopBtn = document.getElementById('stopBtn');
                        if (stopBtn) {
                            stopBtn.disabled = false;
                            stopBtn.textContent = '‚õî Stop Analysis';
                        }
                    }
                    
                    // Update progress
                    if (update.step && update.total) {
                        progressStep.textContent = `Step ${update.step}/${update.total}: ${update.message}`;
                        progressBar.style.width = update.progress + '%';
                        progressBar.textContent = update.progress + '%';
                        
                        // Add to log
                        const logEntry = document.createElement('div');
                        logEntry.className = 'progress-log-entry current';
                        logEntry.textContent = `[${update.step}/${update.total}] ${update.message}`;
                        progressLog.appendChild(logEntry);
                        progressLog.scrollTop = progressLog.scrollHeight;
                        
                        // Mark previous entries as non-current
                        const entries = progressLog.querySelectorAll('.progress-log-entry');
                        entries.forEach((entry, idx) => {
                            if (idx < entries.length - 1) {
                                entry.classList.remove('current');
                            }
                        });
                    }
                };
                
                eventSource.onerror = function() {
                    eventSource.close();
                    progressContainer.classList.add('hidden');
                    btn.disabled = false;
                    videoFileInput.disabled = false;
                    instructions.readOnly = false;
                    btn.textContent = 'üîç Analyze Video';
                    alert('Connection to server lost. Please try again.');
                };
                
            } catch (error) {
                console.error('=== EXCEPTION CAUGHT ===');
                console.error('Error details:', error);
                alert('Error: ' + error.message);
                progressContainer.classList.add('hidden');
                btn.disabled = false;
                videoFileInput.disabled = false;
                instructions.readOnly = false;
                btn.textContent = 'üîç Analyze Video';
            }
        }
        
        function stopAnalysis() {
            console.log('=== STOP REQUESTED ===');
            console.log('Current task ID:', currentTaskId);
            
            // Send stop request to backend
            if (currentTaskId) {
                fetch(`/api/analyze/stop/${currentTaskId}`, {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Stop signal sent:', data);
                })
                .catch(error => {
                    console.error('Error sending stop signal:', error);
                });
            }
            
            // DON'T close SSE connection - wait for backend to send final results
            // The backend will detect cancellation and return partial results
            
            const progressLog = document.getElementById('progressLog');
            progressLog.innerHTML += '<div class="progress-log-entry" style="color: #f44336; font-weight: bold;">‚õî Stop requested - Waiting for partial results...</div>';
            
            // Disable the stop button to prevent multiple clicks
            const stopBtn = document.getElementById('stopBtn');
            if (stopBtn) {
                stopBtn.disabled = true;
                stopBtn.textContent = '‚è≥ Stopping...';
            }
        }
        
        function resetUploadMode() {
            // Stop analysis if running
            stopAnalysis();
            
            // Close SSE connection
            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }
            
            // Clear video
            const videoInput = document.getElementById('videoFile');
            videoInput.value = '';
            
            // Reset checkboxes - check only goals
            document.querySelectorAll('.upload-event-type-checkbox').forEach(cb => {
                cb.checked = (cb.value === 'goal');
            });
            
            // Clear instructions
            document.getElementById('instructions').value = '';
            
            // Reset progress
            document.getElementById('progressContainer').classList.add('hidden');
            document.getElementById('progressLog').innerHTML = '';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            
            // Reset buttons
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.disabled = false;
            analyzeBtn.textContent = 'üîç Analyze Video';
            document.getElementById('stopBtn').style.display = 'none';
            
            // Hide results
            document.getElementById('results').classList.add('hidden');
            currentAnalysisResult = null;
            currentTaskId = null;
            selectedEvents.clear();
        }

        
        async function generateClips() {
            const btn = document.getElementById('generateClipsBtn');
            const clipsList = document.getElementById('clipsList');
            
            if (!currentTaskId || !currentAnalysisResult) {
                alert('No analysis data available');
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating clips...';
            clipsList.innerHTML = '<p style="color: #666; font-size: 14px;">Generating video clips, please wait...</p>';
            
            try {
                const response = await fetch('/api/clips/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        task_id: currentTaskId,
                        events: currentAnalysisResult.events
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to generate clips');
                }
                
                // Display clips list with checkboxes
                if (data.clips && data.clips.length > 0) {
                    const clipsHtml = data.clips.map((clip, idx) => `
                        <li>
                            <div class="clip-left">
                                <input type="checkbox" class="clip-checkbox" data-filename="${clip.filename}" id="clip_${idx}">
                                <label for="clip_${idx}" style="cursor: pointer; flex: 1;">üìπ ${clip.filename} (${clip.timestamp})</label>
                            </div>
                            <a href="/api/clips/download/${clip.filename}" class="clip-download" download>‚¨áÔ∏è Download</a>
                        </li>
                    `).join('');
                    
                    const controlsHtml = `
                        <div class="clips-controls">
                            <button class="select-all-btn" onclick="toggleClipSelectAll(this)">Select All</button>
                            <button class="highlight-reel-btn" onclick="createHighlightReel()" id="highlightReelBtn">
                                üé¨ Create Highlight Reel
                            </button>
                        </div>
                        <div id="highlightResult"></div>
                    `;
                    
                    clipsList.innerHTML = clipsHtml + controlsHtml;
                    btn.textContent = '‚úÖ Clips Generated';
                } else {
                    clipsList.innerHTML = '<p style="color: #999;">No clips were generated.</p>';
                    btn.textContent = 'Generate Clips';
                    btn.disabled = false;
                }
                
            } catch (error) {
                alert('Error generating clips: ' + error.message);
                clipsList.innerHTML = '';
                btn.textContent = 'Generate Clips';
                btn.disabled = false;
            }
        }
        
        function toggleClipSelectAll(btn) {
            const checkboxes = document.querySelectorAll('.clip-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(cb => {
                cb.checked = !allChecked;
            });
            
            btn.textContent = allChecked ? 'Select All' : 'Deselect All';
        }
        
        async function createHighlightReel() {
            const checkboxes = document.querySelectorAll('.clip-checkbox:checked');
            const selectedClips = Array.from(checkboxes).map(cb => cb.dataset.filename);
            
            if (selectedClips.length === 0) {
                alert('Please select at least one clip to create a highlight reel');
                return;
            }
            
            const btn = document.getElementById('highlightReelBtn');
            const resultDiv = document.getElementById('highlightResult');
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Creating highlight reel...';
            resultDiv.innerHTML = '<p style="color: #666; font-size: 14px;">Concatenating clips, please wait...</p>';
            
            try {
                const response = await fetch('/api/clips/concatenate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ clips: selectedClips })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to create highlight reel');
                }
                
                resultDiv.innerHTML = `
                    <div class="highlight-result">
                        ‚úÖ Highlight reel created successfully!<br>
                        üìπ ${data.clips_count} clips concatenated<br>
                        <a href="/api/clips/download/${data.filename}" download>‚¨áÔ∏è Download ${data.filename}</a>
                    </div>
                `;
                btn.textContent = '‚úÖ Highlight Reel Created';
                
            } catch (error) {
                alert('Error creating highlight reel: ' + error.message);
                resultDiv.innerHTML = '';
                btn.textContent = 'üé¨ Create Highlight Reel';
                btn.disabled = false;
            }
        }
        
        function displayResults(data) {
            const results = document.getElementById('results');
            const meta = data.meta || {};
            const wasCancelled = data.cancelled || meta.cancelled || false;
            
            // Add cancellation notice if applicable
            let cancelledNotice = '';
            if (wasCancelled) {
                cancelledNotice = `
                    <div style="background: #fff3cd; border: 1px solid #ffc107; padding: 12px; border-radius: 4px; margin-bottom: 16px;">
                        <strong>‚ö†Ô∏è Analysis Stopped</strong><br>
                        Showing partial results from ${meta.chunks_completed || 'some'}/${meta.total_chunks || 'all'} processed chunks.
                        ${data.events.length > 0 ? 'You can still generate clips from detected events.' : ''}
                    </div>
                `;
            }
            
            // Show metrics
            document.getElementById('metrics').innerHTML = cancelledNotice + `
                <div class="metric">
                    <div class="metric-value">${data.events.length}</div>
                    <div class="metric-label">Events Found${wasCancelled ? ' (Partial)' : ''}</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${meta.processing_ms || 0}ms</div>
                    <div class="metric-label">Processing Time</div>
                </div>
            `;
            
            // Show timestamps for clipping
            if (data.timestamps && data.timestamps.length > 0) {
                const timestampsList = data.timestamps.map(t => {
                    const hours = Math.floor(t / 3600);
                    const mins = Math.floor((t % 3600) / 60);
                    const secs = Math.floor(t % 60);
                    return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                }).join(', ');
                
                document.getElementById('metrics').innerHTML += `
                    <div class="metric" style="grid-column: 1 / -1;">
                        <div style="font-size: 14px; font-weight: bold; margin-bottom: 8px;">‚è±Ô∏è Timestamps for Clipping:</div>
                        <div style="font-family: monospace; font-size: 12px; background: #fff; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">${timestampsList}</div>
                    </div>
                `;
            }
            
            // Show events table
            if (data.events.length > 0) {
                const eventsHtml = `
                    <h3>Detected Events</h3>
                    <div style="margin-bottom: 12px;">
                        <button onclick="clearAllFilters()" class="clear-filters-btn">üîÑ Clear All Filters</button>
                        <span id="filteredCount" style="margin-left: 12px; font-size: 13px; color: #666;"></span>
                    </div>
                    <table class="events-table" id="uploadEventsTable">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Time</th>
                                <th>Description</th>
                                <th>Confidence</th>
                            </tr>
                            <tr class="filter-row">
                                <th><input type="text" class="filter-input" id="uploadFilterType" placeholder="Filter type..." oninput="filterUploadEvents()"></th>
                                <th><input type="text" class="filter-input" id="uploadFilterTime" placeholder="Filter time..." oninput="filterUploadEvents()"></th>
                                <th><input type="text" class="filter-input" id="uploadFilterDescription" placeholder="Filter description..." oninput="filterUploadEvents()"></th>
                                <th><input type="text" class="filter-input" id="uploadFilterConfidence" placeholder="Filter..." oninput="filterUploadEvents()"></th>
                            </tr>
                        </thead>
                        <tbody id="uploadEventsTableBody">
                            ${data.events.map(e => `
                                <tr>
                                    <td><span class="event-badge event-${e.type}">${e.type.toUpperCase()}</span></td>
                                    <td>${Math.floor(e.timestamp / 60)}:${String(Math.floor(e.timestamp % 60)).padStart(2, '0')}</td>
                                    <td>${e.description || 'N/A'}</td>
                                    <td>${e.confidence ? (e.confidence * 100).toFixed(0) + '%' : 'N/A'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                document.getElementById('events').innerHTML = eventsHtml;
            } else {
                document.getElementById('events').innerHTML = '<p>No events detected.</p>';
            }
            
            // Add clips section if we have events with timestamps
            if (data.events.length > 0 && currentTaskId) {
                const clipsSection = `
                    <div class="clips-section">
                        <h3>üé¨ Video Clips</h3>
                        <p style="color: #666; font-size: 14px;">Generate individual clips for each detected event</p>
                        <button class="generate-clips-btn" onclick="generateClips()" id="generateClipsBtn">Generate ${data.events.length} Clips</button>
                        <div id="clipsList" class="clips-list"></div>
                    </div>
                `;
                document.getElementById('events').innerHTML += clipsSection;
            }
            
            results.classList.remove('hidden');
        }
    </script>
</body>
</html>
